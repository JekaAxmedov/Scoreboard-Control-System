<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Заставка</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      height: 100%;
      width: 100%;
      font-family: 'Arial', sans-serif;
      overflow: hidden;
    }

    #splash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(45deg, #000000, #00001a, #00002b);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      opacity: 1;
      transition: opacity 1s ease-out;
    }

    #videoWrapper {
      position: relative;
      width: 85%;
      max-width: 1000px;
      aspect-ratio: 16/9;
    }

    /* Амбилайт подсветка от видео */
    .ambilight-glow {
      position: absolute;
      top: -100px;
      left: -100px;
      right: -100px;
      bottom: -100px;
      border-radius: 40px;
      filter: blur(80px) brightness(1.2);
      opacity: 1;
      transition: all 0.1s ease;
      z-index: 0;
      transform-origin: center;
      pointer-events: none;
    }

    .ambilight-glow::before {
      content: '';
      position: absolute;
      top: -50px;
      left: -50px;
      right: -50px;
      bottom: -50px;
      border-radius: 35px;
      filter: blur(60px);
      opacity: 0.8;
      transition: all 0.1s ease;
      transform-origin: center;
    }

    .ambilight-glow::after {
      content: '';
      position: absolute;
      top: -20px;
      left: -20px;
      right: -20px;
      bottom: -20px;
      border-radius: 30px;
      filter: blur(40px);
      opacity: 0.6;
      transition: all 0.1s ease;
      transform-origin: center;
    }

    /* Пульсация при басах */
    .bass-pulse {
      animation: bassPulse 0.15s ease-out;
    }

    @keyframes bassPulse {
      0% { 
        transform: scale(1); 
        filter: blur(80px) brightness(1.2);
      }
      50% { 
        transform: scale(1.15); 
        filter: blur(95px) brightness(1.7);
      }
      100% { 
        transform: scale(1); 
        filter: blur(80px) brightness(1.2);
      }
    }

    #videoContainer {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 25px;
      overflow: hidden;
      background: #000;
      backdrop-filter: blur(10px);
      box-shadow: 
        0 25px 50px rgba(0, 0, 0, 0.9),
        inset 0 0 0 2px rgba(255, 255, 255, 0.1);
      z-index: 2;
    }

    #introVideo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 25px;
      transition: opacity 0.3s ease-out;
    }

    /* Навигационные кнопки */
    .nav-button {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 15;
      opacity: 0;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
      user-select: none;
    }

    .nav-button:hover {
      background: rgba(255, 255, 255, 0.9);
      color: #000;
      transform: translateY(-50%) scale(1.1);
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.6);
    }

    .nav-button:active {
      transform: translateY(-50%) scale(0.95);
    }

    .nav-button.show {
      opacity: 0.8;
    }

    .nav-button.show:hover {
      opacity: 1;
    }

    #prevBtn {
      left: -80px;
    }

    #nextBtn {
      right: -80px;
    }

    /* Индикатор текущего видео */
    .video-indicator {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 8px;
      z-index: 15;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .video-indicator.show {
      opacity: 0.8;
    }

    .indicator-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.4);
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .indicator-dot.active {
      background: white;
      transform: scale(1.3);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
    }

    .indicator-dot:hover {
      background: rgba(255, 255, 255, 0.7);
      transform: scale(1.1);
    }

    #loadingOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 18px;
      z-index: 20;
      transition: opacity 0.5s ease-out;
      border-radius: 25px;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-top: 3px solid #fff;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #continueBtn {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      padding: 15px 35px;
      font-size: 18px;
      font-weight: 600;
      color: white;
      background: linear-gradient(45deg, #667eea, #764ba2);
      border: none;
      border-radius: 50px;
      cursor: pointer;
      opacity: 0;
      transition: all 0.3s ease;
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
      backdrop-filter: blur(10px);
      z-index: 3;
    }

    #continueBtn:hover {
      transform: translateX(-50%) translateY(15px) scale(1.05);
      box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
    }

    #continueBtn:active {
      transform: translateX(-50%) translateY(18px) scale(0.98);
    }

    #continueBtn.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .error-message {
      color: #ff6b6b;
      text-align: center;
      padding: 20px;
      font-size: 16px;
    }

    .fallback-content {
      display: none;
      text-align: center;
      color: white;
      padding: 40px;
    }

    .fallback-content h1 {
      font-size: 3em;
      margin-bottom: 20px;
      background: linear-gradient(45deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .fallback-content p {
      font-size: 1.2em;
      opacity: 0.8;
      margin-bottom: 30px;
    }

    #volumeSlider {
      position: absolute;
      bottom: 90px;
      left: 50%;
      transform: translateX(-50%);
      width: 220px;
      height: 8px;
      -webkit-appearance: none;
      background: linear-gradient(45deg, #667eea, #764ba2);
      border-radius: 50px;
      outline: none;
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
      cursor: pointer;
      z-index: 3;
    }

    /* Ползунок (бегунок) */
    #volumeSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #764ba2;
      box-shadow: 0 4px 10px rgba(102, 126, 234, 0.6);
      cursor: pointer;
      transition: transform 0.2s;
    }

    #volumeSlider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
    }

    /* Для Firefox */
    #volumeSlider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid #764ba2;
      box-shadow: 0 4px 10px rgba(102, 126, 234, 0.6);
      cursor: pointer;
      transition: transform 0.2s;
    }

    #volumeSlider::-moz-range-thumb:hover {
      transform: scale(1.2);
    }

    /* Индикатор басов */
    #bassIndicator {
      position: absolute;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      z-index: 3;
      display: none;
    }

    .bass-active {
      color: #ff6ec4 !important;
      text-shadow: 0 0 10px #ff6ec4;
    }

    @media (max-width: 768px) {
      #videoWrapper {
        width: 95%;
      }
      
      .nav-button {
        width: 50px;
        height: 50px;
        font-size: 22px;
      }
      
      #prevBtn {
        left: -65px;
      }

      #nextBtn {
        right: -65px;
      }
      
      .ambilight-glow {
        top: -50px;
        left: -50px;
        right: -50px;
        bottom: -50px;
        border-radius: 35px;
        filter: blur(50px) brightness(1.2);
      }
      
      .ambilight-glow::before {
        top: -30px;
        left: -30px;
        right: -30px;
        bottom: -30px;
        filter: blur(40px);
      }
      
      .ambilight-glow::after {
        top: -10px;
        left: -10px;
        right: -10px;
        bottom: -10px;
        filter: blur(20px);
      }
      
      #videoContainer {
        border-radius: 20px;
      }
      
      #introVideo {
        border-radius: 20px;
      }
      
      #loadingOverlay {
        border-radius: 20px;
      }
      
      #continueBtn {
        bottom: 20px;
        padding: 12px 25px;
        font-size: 16px;
      }
      
      .fallback-content h1 {
        font-size: 2em;
      }
    }

    @media (max-width: 480px) {
      #prevBtn {
        left: -20px;
        top: 30%;
      }

      #nextBtn {
        right: -20px;
        top: 30%;
      }

      .nav-button {
        width: 40px;
        height: 40px;
        font-size: 18px;
        background: rgba(0, 0, 0, 0.8);
      }
    }

    /* Анимация появления */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    #videoWrapper {
      animation: fadeIn 1.2s ease-out;
    }

    /* Анимация исчезновения */
    .fade-out {
      opacity: 0 !important;
      transform: scale(1.1);
    }

    /* Анимация переключения видео */
    .video-fade-out {
      opacity: 0;
    }
  </style>
</head>
<body>

  <div id="splash">
    <div id="videoWrapper">
      <canvas id="hiddenCanvas" style="display: none;"></canvas>
      <div class="ambilight-glow" id="ambilightGlow"></div>
      <div id="videoContainer">
        <video id="introVideo" playsinline preload="auto" crossorigin="anonymous"></video>
        
        <!-- Навигационные кнопки -->
        <button class="nav-button" id="prevBtn" title="Предыдущее видео">‹</button>
        <button class="nav-button" id="nextBtn" title="Следующее видео">›</button>
        
        <!-- Индикатор текущего видео -->
        <div class="video-indicator" id="videoIndicator"></div>
        
        <div id="loadingOverlay">
          <div class="spinner"></div>
          <div>Загрузка видео...</div>
        </div>
      </div>
    </div>

    <div class="fallback-content">
      <h1>Добро пожаловать!</h1>
      <p>Готовы начать путешествие?</p>
    </div>

    <button id="continueBtn">Продолжить</button>
    <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.2">
    <div id="bassIndicator">🎵 Bass Detection</div>
  </div>

  <script>
    const video = document.getElementById('introVideo');
    const btn = document.getElementById('continueBtn');
    const splash = document.getElementById('splash');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const fallbackContent = document.querySelector('.fallback-content');
    const videoContainer = document.getElementById('videoContainer');
    const volumeSlider = document.getElementById('volumeSlider');
    const hiddenCanvas = document.getElementById('hiddenCanvas');
    const ambilightGlow = document.getElementById('ambilightGlow');
    const bassIndicator = document.getElementById('bassIndicator');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const videoIndicator = document.getElementById('videoIndicator');

    const ctx = hiddenCanvas.getContext('2d', {
        willReadFrequently: true
    });

    const videoSources = [
        "video/intro1.mp4",
        "video/intro2.mp4", 
        "video/intro3.mp4",
        "video/intro4.mp4"
    ];

    let currentVideoIndex = Math.floor(Math.random() * videoSources.length);
    let videoLoaded = false;
    let canPlay = false;
    let isAnalyzing = false;
    let audioContext = null;
    let analyser = null;
    let dataArray = null;
    let source = null;
    let bassDetectionActive = false;
    let isTransitioning = false;

    // Инициализация индикаторов видео
    function initVideoIndicators() {
      videoSources.forEach((_, index) => {
        const dot = document.createElement('div');
        dot.className = 'indicator-dot';
        if (index === currentVideoIndex) {
          dot.classList.add('active');
        }
        dot.addEventListener('click', () => switchToVideo(index));
        videoIndicator.appendChild(dot);
      });
    }

    // Обновление индикатора
    function updateVideoIndicator() {
      const dots = videoIndicator.querySelectorAll('.indicator-dot');
      dots.forEach((dot, index) => {
        dot.classList.toggle('active', index === currentVideoIndex);
      });
    }

    // Показать навигационные элементы
    function showNavigation() {
      setTimeout(() => {
        prevBtn.classList.add('show');
        nextBtn.classList.add('show');
        videoIndicator.classList.add('show');
      }, 1000);
    }

    // Переключение на конкретное видео
    function switchToVideo(index) {
      if (isTransitioning || index === currentVideoIndex) return;
      
      isTransitioning = true;
      const wasPlaying = !video.paused;
      const currentVolume = video.volume;
      
      // Плавное затухание текущего видео
      video.classList.add('video-fade-out');
      
      setTimeout(() => {
        currentVideoIndex = index;
        video.src = videoSources[currentVideoIndex];
        updateVideoIndicator();
        
        // Показать загрузку
        loadingOverlay.style.display = 'flex';
        loadingOverlay.style.opacity = '1';
        
        // Когда новое видео загрузится
        const handleNewVideoLoad = () => {
          video.classList.remove('video-fade-out');
          loadingOverlay.style.opacity = '0';
          setTimeout(() => {
            loadingOverlay.style.display = 'none';
          }, 500);
          
          video.volume = currentVolume;
          if (wasPlaying) {
            const playPromise = video.play();
            if (playPromise !== undefined) {
              playPromise.catch(console.warn);
            }
          }
          
          isTransitioning = false;
          video.removeEventListener('loadeddata', handleNewVideoLoad);
        };
        
        video.addEventListener('loadeddata', handleNewVideoLoad);
      }, 300);
    }

    // Предыдущее видео
    function previousVideo() {
      const prevIndex = (currentVideoIndex - 1 + videoSources.length) % videoSources.length;
      switchToVideo(prevIndex);
    }

    // Следующее видео  
    function nextVideo() {
      const nextIndex = (currentVideoIndex + 1) % videoSources.length;
      switchToVideo(nextIndex);
    }

    // Обработчики навигации
    prevBtn.addEventListener('click', previousVideo);
    nextBtn.addEventListener('click', nextVideo);

    // Клавиатурная навигация
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') {
        previousVideo();
      } else if (e.key === 'ArrowRight') {
        nextVideo();
      }
    });

    // Функция для показа кнопки
    function showContinueButton() {
      setTimeout(() => {
        btn.classList.add('show');
        showNavigation();
      }, 3000);
    }

    // Инициализация
    initVideoIndicators();
    video.src = videoSources[currentVideoIndex];
    video.volume = 0.1;

    // при изменении ползунка
    volumeSlider.addEventListener('input', () => {
      video.volume = volumeSlider.value;
    });

    // Инициализация Web Audio API для анализа басов
    function initAudioAnalysis() {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        source = audioContext.createMediaElementSource(video);
        
        source.connect(analyser);
        analyser.connect(audioContext.destination);
        
        analyser.fftSize = 256;
        const bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        
        bassDetectionActive = true;
        bassIndicator.style.display = 'block';
        
        console.log('Аудиоанализ инициализирован');
      } catch (error) {
        console.log('Web Audio API недоступен:', error);
        bassDetectionActive = false;
      }
    }

    // Анализ басов
    function analyzeBass() {
      if (!bassDetectionActive || !analyser) return 0;
      
      analyser.getByteFrequencyData(dataArray);
      
      // Анализируем низкие частоты (басы) - первые 15% спектра
      let bassSum = 0;
      const bassRange = Math.floor(dataArray.length * 0.15);
      
      for (let i = 0; i < bassRange; i++) {
        bassSum += dataArray[i];
      }
      
      const bassAverage = bassSum / bassRange;
      return bassAverage / 255; // Нормализуем до 0-1
    }

    // Функция для извлечения цветов из видео
    function getVideoColors() {
      if (!video.videoWidth || !video.videoHeight) return null;

      // Устанавливаем размер canvas
      const scale = 0.1; // Уменьшаем для производительности
      hiddenCanvas.width = video.videoWidth * scale;
      hiddenCanvas.height = video.videoHeight * scale;
      
      // Рисуем кадр видео
      ctx.drawImage(video, 0, 0, hiddenCanvas.width, hiddenCanvas.height);
      
      const imageData = ctx.getImageData(0, 0, hiddenCanvas.width, hiddenCanvas.height);
      const data = imageData.data;
      
      // Анализируем цвета по краям для амбилайт эффекта
      const colors = {
        top: [0, 0, 0],
        bottom: [0, 0, 0],
        left: [0, 0, 0],
        right: [0, 0, 0],
        center: [0, 0, 0]
      };
      
      const width = hiddenCanvas.width;
      const height = hiddenCanvas.height;
      
      // Собираем цвета по краям
      const edgePixels = {
        top: [],
        bottom: [],
        left: [],
        right: [],
        center: []
      };
      
      // Верхний и нижний край
      for (let x = 0; x < width; x += 2) {
        const topIndex = x * 4;
        const bottomIndex = ((height - 1) * width + x) * 4;
        
        if (data[topIndex + 3] > 0) {
          edgePixels.top.push([data[topIndex], data[topIndex + 1], data[topIndex + 2]]);
        }
        if (data[bottomIndex + 3] > 0) {
          edgePixels.bottom.push([data[bottomIndex], data[bottomIndex + 1], data[bottomIndex + 2]]);
        }
      }
      
      // Левый и правый край
      for (let y = 0; y < height; y += 2) {
        const leftIndex = y * width * 4;
        const rightIndex = (y * width + width - 1) * 4;
        
        if (data[leftIndex + 3] > 0) {
          edgePixels.left.push([data[leftIndex], data[leftIndex + 1], data[leftIndex + 2]]);
        }
        if (data[rightIndex + 3] > 0) {
          edgePixels.right.push([data[rightIndex], data[rightIndex + 1], data[rightIndex + 2]]);
        }
      }
      
      // Центр для общего тона
      const centerX = Math.floor(width / 2);
      const centerY = Math.floor(height / 2);
      const centerRadius = Math.min(width, height) * 0.2;
      
      for (let x = centerX - centerRadius; x < centerX + centerRadius; x += 3) {
        for (let y = centerY - centerRadius; y < centerY + centerRadius; y += 3) {
          if (x >= 0 && x < width && y >= 0 && y < height) {
            const index = (y * width + x) * 4;
            if (data[index + 3] > 0) {
              edgePixels.center.push([data[index], data[index + 1], data[index + 2]]);
            }
          }
        }
      }
      
      // Вычисляем средние цвета
      Object.keys(edgePixels).forEach(edge => {
        if (edgePixels[edge].length > 0) {
          let r = 0, g = 0, b = 0;
          edgePixels[edge].forEach(pixel => {
            r += pixel[0];
            g += pixel[1];
            b += pixel[2];
          });
          
          colors[edge] = [
            Math.round(r / edgePixels[edge].length),
            Math.round(g / edgePixels[edge].length),
            Math.round(b / edgePixels[edge].length)
          ];
        }
      });
      
      return colors;
    }

    // Основная функция амбилайт анализа
    function updateAmbilight() {
      if (!video.videoWidth || video.paused || video.ended) return;
      
      const colors = getVideoColors();
      if (!colors) return;
      
      // Анализируем басы
      const bassLevel = analyzeBass();
      const isBassPeak = bassLevel > 0.4;
      
      // Обновляем индикатор басов
      if (isBassPeak) {
        bassIndicator.classList.add('bass-active');
        bassIndicator.textContent = `🎵 Bass: ${Math.round(bassLevel * 100)}%`;
      } else {
        bassIndicator.classList.remove('bass-active');
        bassIndicator.textContent = '🎵 Bass Detection';
      }
      
      // Создаем градиент на основе цветов видео
      const centerColor = colors.center;
      const topColor = colors.top;
      const bottomColor = colors.bottom;
      const leftColor = colors.left;
      const rightColor = colors.right;
      
      // Усиливаем насыщенность, используя более агрессивные коэффициенты
      const saturation = 1.8 + (bassLevel * 1.0);
      const brightness = 1.0 + (bassLevel * 0.5);
      
      const enhanceColor = (color) => {
        return [
          Math.min(255, Math.round(color[0] * saturation * brightness)),
          Math.min(255, Math.round(color[1] * saturation * brightness)),
          Math.min(255, Math.round(color[2] * saturation * brightness))
        ];
      };
      
      const enhancedCenter = enhanceColor(centerColor);
      const enhancedTop = enhanceColor(topColor);
      const enhancedBottom = enhanceColor(bottomColor);
      const enhancedLeft = enhanceColor(leftColor);
      const enhancedRight = enhanceColor(rightColor);
      
      // Создаем сложный градиент
      const centerRgba = `rgba(${enhancedCenter[0]}, ${enhancedCenter[1]}, ${enhancedCenter[2]}, 0.9)`;
      const topRgba = `rgba(${enhancedTop[0]}, ${enhancedTop[1]}, ${enhancedTop[2]}, 0.7)`;
      const bottomRgba = `rgba(${enhancedBottom[0]}, ${enhancedBottom[1]}, ${enhancedBottom[2]}, 0.7)`;
      const leftRgba = `rgba(${enhancedLeft[0]}, ${enhancedLeft[1]}, ${enhancedLeft[2]}, 0.7)`;
      const rightRgba = `rgba(${enhancedRight[0]}, ${enhancedRight[1]}, ${enhancedRight[2]}, 0.7)`;
      
      // Применяем градиент с учетом направлений
      const gradient = `radial-gradient(ellipse at center, ${centerRgba} 0%, ${topRgba} 25%, ${rightRgba} 50%, ${bottomRgba} 75%, ${leftRgba} 100%)`;
      
      ambilightGlow.style.background = gradient;
      
      // Добавляем пульсацию при басах
      if (isBassPeak) {
        ambilightGlow.classList.remove('bass-pulse');
        void ambilightGlow.offsetWidth; // Принудительный reflow
        ambilightGlow.classList.add('bass-pulse');
      }
      
      // Обновляем псевдо-элементы с большим эффектом
      const style = document.createElement('style');
      style.textContent = `
        .ambilight-glow::before {
          background: 
            radial-gradient(ellipse 200% 200% at 30% 30%, ${topRgba} 0%, transparent 60%),
            radial-gradient(ellipse 200% 200% at 70% 30%, ${rightRgba} 0%, transparent 60%),
            radial-gradient(ellipse 200% 200% at 70% 70%, ${bottomRgba} 0%, transparent 60%),
            radial-gradient(ellipse 200% 200% at 30% 70%, ${leftRgba} 0%, transparent 60%) !important;
        }
        .ambilight-glow::after {
          background: 
            radial-gradient(ellipse 300% 300% at center, ${centerRgba} 0%, transparent 50%),
            conic-gradient(from 0deg at center, ${topRgba} 0deg, ${rightRgba} 90deg, ${bottomRgba} 180deg, ${leftRgba} 270deg, ${topRgba} 360deg) !important;
        }
      `;
      
      const oldStyle = document.querySelector('#ambilight-style');
      if (oldStyle) oldStyle.remove();
      style.id = 'ambilight-style';
      document.head.appendChild(style);
    }

    // Запуск амбилайт анализа
    function startAmbilight() {
      if (isAnalyzing) return;
      isAnalyzing = true;
      
      // Инициализируем аудиоанализ при первом воспроизведении
      if (!audioContext) {
        initAudioAnalysis();
      }
      
      function animate() {
        if (!video.paused && !video.ended && videoLoaded) {
          updateAmbilight();
        }
        requestAnimationFrame(animate);
      }
      animate();
    }

    // Обработка загрузки видео
    video.addEventListener('loadeddata', () => {
      videoLoaded = true;
      loadingOverlay.style.opacity = '0';
      setTimeout(() => {
        loadingOverlay.style.display = 'none';
      }, 500);
      
      const playPromise = video.play();
      if (playPromise !== undefined) {
        playPromise
          .then(() => {
            canPlay = true;
            video.volume = 0.1;
            startAmbilight();
            showContinueButton();
          })
          .catch((error) => {
            console.log('Автовоспроизведение заблокировано:', error);
            showVideoControls();
          });
      }
    });

    // Если видео не загрузилось
    video.addEventListener('error', (e) => {
      console.error('Ошибка загрузки видео:', e);
      showFallback();
    });

    // Таймаут на случай, если видео долго грузится
    setTimeout(() => {
      if (!videoLoaded) {
        showFallback();
      }
    }, 10000);

    // Показать fallback контент
    function showFallback() {
      videoContainer.style.display = 'none';
      fallbackContent.style.display = 'block';
      showContinueButton();
    }

    // Показать контролы для ручного запуска
    function showVideoControls() {
      // Если кнопка уже есть — не создаём заново
      if (videoContainer.querySelector('.play-button-fallback')) return;

      video.controls = true; // Показываем нативные контролы на всякий случай
      video.muted = false;
      video.volume = 0.1;

      const playButton = document.createElement('button');
      playButton.innerHTML = '▶ Воспроизвести со звуком';
      playButton.className = 'play-button-fallback'; // Для избежания дублирования
      playButton.style.cssText = `
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          padding: 15px 30px;
          font-size: 18px;
          background: rgba(0, 0, 0, 0.8);
          color: white;
          border: 2px solid white;
          border-radius: 25px;
          cursor: pointer;
          z-index: 5;
          box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
      `;

      playButton.addEventListener('click', async (e) => {
          e.stopPropagation(); // Останавливаем всплытие, чтобы не вызвать общий обработчик клика снова

          // Разблокируем AudioContext
          if (audioContext && audioContext.state === 'suspended') {
            await audioContext.resume().catch(console.warn);
          }

          // Пробуем воспроизвести
          const playPromise = video.play();
          if (playPromise) {
            playPromise
                .then(() => {
                playButton.remove();
                video.controls = false; // Убираем нативные контролы
                canPlay = true;
                if (!isAnalyzing) startAmbilight();
                showContinueButton(); // Показываем кнопку "Продолжить"
                })
                .catch((error) => {
                console.error('❌ Не удалось воспроизвести видео:', error);
                alert('Пожалуйста, включите звук вручную и нажмите кнопку ещё раз');
                });
          }
      });

      videoContainer.appendChild(playButton);
    }

    // Переход на следующую страницу
    btn.addEventListener('click', () => {
      splash.classList.add('fade-out');
      
      setTimeout(() => {
        window.location.href = 'main.html';
      }, 1000);
    });

    // Обработка клика для включения звука на мобильных устройствах
    document.addEventListener('click', async function(event) {
      // 1. Всегда разблокируем AudioContext, если он существует
      if (audioContext && audioContext.state === 'suspended') {
          try {
            await audioContext.resume();
            console.log('✅ AudioContext разблокирован');
          } catch (e) {
            console.warn('⚠️ Не удалось разблокировать AudioContext:', e);
          }
      }

      // 2. Если видео загружено, но ещё не играет — пробуем запустить
      if (videoLoaded && video.paused) {
          video.muted = false;
          video.volume = 0.1;
          
          const playPromise = video.play();
          if (playPromise !== undefined) {
            playPromise
                .then(() => {
                console.log('✅ Видео запущено со звуком');
                canPlay = true;
                if (!isAnalyzing) startAmbilight(); // Запускаем амбилайт, если ещё не запущен
                })
                .catch((error) => {
                console.warn('❌ Автовоспроизведение заблокировано:', error);
                // Показываем кнопку воспроизведения как fallback
                showVideoControls();
                });
          }
      } 
      // 3. Если видео уже играет, но звук отключен — включаем звук
      else if (video.muted && !video.paused) {
          video.muted = false;
          video.volume = 0.1;
          console.log('🔊 Звук включён');
      }
    });
  </script>

</body>
</html>