<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Control Panel v2.0</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="style.css">
    <style>
        /* Встроенные стили для улучшенного UX */
        .connection-indicator {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
            color: white;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .connection-indicator.connected {
            background-color: #28a745;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
        }
        
        .connection-indicator.connecting {
            background-color: #ffc107;
            animation: pulse 1.5s infinite;
        }
        
        .connection-indicator.disconnected {
            background-color: #dc3545;
            animation: shake 0.5s ease-in-out;
        }
        
        .error-message {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }
        
        .success-message {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .disabled {
            opacity: 0.6;
            pointer-events: none;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .loading {
            position: relative;
        }
        
        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            right: 10px;
            width: 16px;
            height: 16px;
            margin-top: -8px;
            border: 2px solid #ccc;
            border-top-color: #333;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Индикатор соединения -->
    <div id="connectionIndicator" class="connection-indicator connecting">Подключение...</div>
    
    <!-- Сообщения об ошибках -->
    <div id="errorMessage" class="error-message"></div>
    <div id="successMessage" class="success-message"></div>
    
    <!-- Контейнер для фона -->
    <div class="background-container" id="backgroundContainer">
        <img id="backgroundImage" src="" alt="Фон" style="display: none;">
    </div>
    <!-- Хит-слой для перетаскивания фона -->
    <div id="backgroundHitLayer" style="
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5; /* Между фоном и UI */
        pointer-events: none; /* По умолчанию — не мешает */
        display: none;
    "></div>
    <div class="container">
        <div class="score-display">
            <div class="team">
                <h2>Команда 1</h2>
                <span id="team1Score">0</span>
                <div>
                    <button onclick="sendCommand('add_goal', {team: 1})" aria-label="Добавить гол команде 1">Гол</button>
                    <button onclick="sendCommand('undo_goal', {team: 1})" aria-label="Отменить гол команде 1">Отмена</button>
                </div>
            </div>
            
            <div class="timer">
                <h2 id="timerDisplay">00:00</h2>
                <div id="halfIndicator">1 тайм</div>
            </div>
            
            <div class="team">
                <h2>Команда 2</h2>
                <span id="team2Score">0</span>
                <div>
                    <button onclick="sendCommand('add_goal', {team: 2})" aria-label="Добавить гол команде 2">Гол</button>
                    <button onclick="sendCommand('undo_goal', {team: 2})" aria-label="Отменить гол команде 2">Отмена</button>
                </div>
            </div>
        </div>

        <div class="controls">
            <button id="startHalf1" onclick="toggleHalf(1)" aria-label="Управление первым таймом">Старт 1 тайм</button>
            <button id="startHalf2" onclick="toggleHalf(2)" aria-label="Управление вторым таймом">Старт 2 тайм</button>
            <button onclick="sendCommand('reset', {half: currentHalf})" aria-label="Сбросить счёт">Сброс</button>
            <label>
                <input type="checkbox" id="autoStop" onchange="sendCommand('toggle_auto_stop')" aria-label="Автоматическая остановка таймера">
                Авто-стоп
            </label>
            <button id="muteBtn" onclick="sendCommand('toggle_mute')" aria-label="Переключить звук">Mute</button>
        </div>
        
        <div style="margin-top: 15px; display: flex; align-items: center; gap: 10px;">
            <label for="timeInput">Установить время:</label>
            <input type="text" id="timeInput" placeholder="ММ:СС" maxlength="5" 
                   style="width: 80px; padding: 8px; font-size: 1em;" 
                   aria-label="Время в формате ММ:СС">
            <button onclick="setCustomTime()" style="padding: 8px 12px;" aria-label="Применить установленное время">Применить</button>
        </div>

        <!-- Управление фоном -->
        <div class="background-controls">
            <h3>Управление фоном</h3>
            <input type="file" id="backgroundUpload" accept="image/*" aria-label="Выбрать файл изображения для фона">
            <button onclick="document.getElementById('backgroundUpload').click()">Выбрать фон</button>
            <button id="fixBackgroundBtn" onclick="toggleBackgroundFixed()">Зафиксировать фон</button>
            <div class="scale-controls">
                <button onclick="scaleBackground(1.1)" aria-label="Увеличить масштаб фона">+ Увеличить</button>
                <button onclick="scaleBackground(0.9)" aria-label="Уменьшить масштаб фона">- Уменьшить</button>
            </div>
        </div>

        <!-- Управление позицией фона -->
        <details class="background-position-controls" style="margin-top: 15px; background: #f8f9fa; border-radius: 8px;">
            <summary style="padding: 10px; cursor: pointer; font-weight: bold;">Управление позицией фона</summary>
            <div style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label>Шаг (px):</label>
                    <input type="number" id="bgStep" value="10" min="1" max="500" style="width: 60px;">
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; width: fit-content; margin: 0 auto;">
                    <div></div>
                    <button onclick="moveBackground(0, -1)" style="padding: 10px; font-size: 1.2em;">▲</button>
                    <div></div>
                    <button onclick="moveBackground(-1, 0)" style="padding: 10px; font-size: 1.2em;">◄</button>
                    <button onclick="resetBackgroundPosition()" style="padding: 10px; font-size: 0.9em;">Сброс</button>
                    <button onclick="moveBackground(1, 0)" style="padding: 10px; font-size: 1.2em;">►</button>
                    <div></div>
                    <button onclick="moveBackground(0, 1)" style="padding: 10px; font-size: 1.2em;">▼</button>
                    <div></div>
                </div>

                <div style="display: flex; align-items: center; gap: 10px; justify-content: center;">
                    <label>X:</label>
                    <input type="number" id="bgX" value="0" style="width: 80px;">
                    <label>Y:</label>
                    <input type="number" id="bgY" value="0" style="width: 80px;">
                    <button onclick="applyBackgroundPosition()" style="padding: 8px 12px;">Применить</button>
                </div>
            </div>
        </details>

        <!-- Настройка шрифтов -->
        <div class="font-controls" style="margin: 20px 0; padding: 20px; background: #e9ecef; border-radius: 10px;">
            <h3>Настройка шрифтов</h3>

            <div>
                <label for="scoreSize">Размер счёта: 
                    <input type="number" id="scoreSize" min="1" max="10" step="0.1" value="4" aria-label="Размер шрифта счёта">
                </label>
                <button onclick="updateFontSize('teamScore', 'scoreSize')">Применить</button>
            </div>

            <div style="margin-top: 10px;">
                <label for="timerSize">Размер таймера: 
                    <input type="number" id="timerSize" min="1" max="10" step="0.1" value="6" aria-label="Размер шрифта таймера">
                </label>
                <button onclick="updateFontSize('timer', 'timerSize')">Применить</button>
            </div>

            <div style="margin-top: 15px;">
                <label for="scoreFont">Шрифт счёта:</label>
                <select id="scoreFont" aria-label="Выбор шрифта для счёта"></select>
                <button onclick="updateFontFamily('teamScore', 'scoreFont')">Применить</button>
            </div>

            <div style="margin-top: 10px;">
                <label for="timerFont">Шрифт таймера:</label>
                <select id="timerFont" aria-label="Выбор шрифта для таймера"></select>
                <button onclick="updateFontFamily('timer', 'timerFont')">Применить</button>
            </div>
        </div>
    </div>

    <script>
        // === Конфигурация ===
        const CONFIG = {
            RECONNECT_INTERVAL: 3000,
            RECONNECT_MAX_ATTEMPTS: 10,
            MESSAGE_TIMEOUT: 3000
        };

        // === Состояние соединения ===
        let ws;
        let currentHalf = 1;
        let currentScale = 1.0;
        let isBackgroundFixed = false;
        let state = {};
        let reconnectAttempts = 0;
        let isConnected = false;

        // === Утилиты ===
        function showMessage(text, type = 'error') {
            const messageEl = document.getElementById(type + 'Message');
            if (messageEl) {
                messageEl.textContent = text;
                messageEl.style.display = 'block';
                setTimeout(() => {
                    messageEl.style.display = 'none';
                }, CONFIG.MESSAGE_TIMEOUT);
            }
        }

        function showError(text) {
            showMessage(text, 'error');
            console.error(text);
        }

        function showSuccess(text) {
            showMessage(text, 'success');
            console.log(text);
        }

        function updateConnectionStatus(status) {
            const indicator = document.getElementById('connectionIndicator');
            const container = document.querySelector('.container');
            
            indicator.className = `connection-indicator ${status}`;
            
            switch (status) {
                case 'connected':
                    indicator.textContent = '🟢 Подключено';
                    container.classList.remove('disabled');
                    isConnected = true;
                    reconnectAttempts = 0;
                    break;
                case 'connecting':
                    indicator.textContent = '🟡 Подключение...';
                    container.classList.add('disabled');
                    isConnected = false;
                    break;
                case 'disconnected':
                    indicator.textContent = '🔴 Отключено';
                    container.classList.add('disabled');
                    isConnected = false;
                    break;
            }
        }

        function throttle(func, limit) {
            let lastFunc;
            let lastRan;
            return function(...args) {
                if (!lastRan) {
                    func.apply(this, args);
                    lastRan = Date.now();
                } else {
                    clearTimeout(lastFunc);
                    lastFunc = setTimeout(() => {
                        if ((Date.now() - lastRan) >= limit) {
                            func.apply(this, args);
                            lastRan = Date.now();
                        }
                    }, limit - (Date.now() - lastRan));
                }
            }
        }

        // === WebSocket соединение ===
        function connect() {
            try {
                updateConnectionStatus('connecting');
                
                // Определяем URL динамически
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}`;
                
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    console.log('WebSocket подключен');
                    updateConnectionStatus('connected');
                    showSuccess('Соединение установлено');
                };
                
                ws.onmessage = (event) => {
                    try {
                        handleMessage(event);
                    } catch (error) {
                        showError(`Ошибка обработки сообщения: ${error.message}`);
                    }
                };
                
                ws.onclose = (event) => {
                    console.log('WebSocket закрыт:', event.code, event.reason);
                    updateConnectionStatus('disconnected');
                    
                    if (reconnectAttempts < CONFIG.RECONNECT_MAX_ATTEMPTS) {
                        reconnectAttempts++;
                        showError(`Соединение потеряно. Попытка переподключения ${reconnectAttempts}/${CONFIG.RECONNECT_MAX_ATTEMPTS}...`);
                        setTimeout(connect, CONFIG.RECONNECT_INTERVAL);
                    } else {
                        showError('Превышено максимальное количество попыток переподключения');
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket ошибка:', error);
                    updateConnectionStatus('disconnected');
                    showError('Ошибка соединения с сервером');
                };
                
            } catch (error) {
                console.error('Ошибка создания WebSocket:', error);
                showError('Не удалось создать соединение');
                updateConnectionStatus('disconnected');
            }
        }

        // === Обработка сообщений ===
        function handleMessage(event) {
            const data = JSON.parse(event.data);
            
            switch (data.type) {
                case 'element_position_update':
                    // Опционально: можно сохранить позиции в state для будущего использования
                    if (!state.positions) state.positions = {};
                    state.positions[data.element] = data.position;
                    // Пока не обновляем UI — но ошибка пропадёт
                    break;
                case 'full_state':
                    updateUI(data.state);
                    break;
                case 'score_update':
                    document.getElementById('team1Score').textContent = data.team1;
                    document.getElementById('team2Score').textContent = data.team2;
                    break;
                case 'time_update':
                    updateTimer(data.time);
                    break;
                case 'mute_state':
                    document.getElementById('muteBtn').textContent = data.muted ? 'Unmute' : 'Mute';
                    break;
                case 'auto_stop_update':
                    const autoStopCb = document.getElementById('autoStop');
                    if (autoStopCb) autoStopCb.checked = data.autoStop || false;
                    break;
                case 'background_update':
                    if (data.background.image) setupBackground(data.background);
                    break;
                case 'background_size_update':
                    if (data.scale !== undefined) {
                        currentScale = data.scale;
                        const img = document.getElementById('backgroundImage');
                        if (img) img.style.transform = `scale(${currentScale})`;
                    }
                    break;
                case 'background_fixed_update':
                    updateBackgroundFixedState(data.fixed || false);
                    break;
                case 'font_size_update':
                    // Обновляем значение в UI, чтобы оно синхронизировалось
                    if (data.element === 'teamScore') {
                        const scoreSizeEl = document.getElementById('scoreSize');
                        if (scoreSizeEl) scoreSizeEl.value = data.size;
                    } else if (data.element === 'timer') {
                        const timerSizeEl = document.getElementById('timerSize');
                        if (timerSizeEl) timerSizeEl.value = data.size;
                    }
                    break;
                case 'background_position_update':
                    const img = document.getElementById('backgroundImage');
                    if (img && img.style.display !== 'none') {
                        const x = data.position?.x || 0;
                        const y = data.position?.y || 0;
                        img.style.left = x + 'px';
                        img.style.top = y + 'px';
                    }
                    break;
                case 'font_family_update':
                    if (data.element === 'teamScore') {
                        const scoreFontEl = document.getElementById('scoreFont');
                        if (scoreFontEl) scoreFontEl.value = data.fontFamily;
                    } else if (data.element === 'timer') {
                        const timerFontEl = document.getElementById('timerFont');
                        if (timerFontEl) timerFontEl.value = data.fontFamily;
                    }
                    break;
                case 'available_fonts':
                    updateFontSelects(data.fonts);
                    break;
                case 'error':
                    showError(`Ошибка сервера: ${data.message}`);
                    break;
                default:
                    console.warn('Неизвестный тип сообщения:', data.type);
            }
        }

        // === Команды ===
        function sendCommand(cmd, params = {}) {
            if (!isConnected) {
                showError('Нет соединения с сервером');
                return false;
            }
            
            try {
                const command = { command: cmd, ...params };
                ws.send(JSON.stringify(command));
                return true;
            } catch (error) {
                showError(`Ошибка отправки команды: ${error.message}`);
                return false;
            }
        }

        // === Управление временем ===
        function setCustomTime() {
            const timeInput = document.getElementById('timeInput');
            const timeStr = timeInput.value.trim();
            
            if (!timeStr) {
                showError('Введите время');
                timeInput.focus();
                return;
            }

            const parts = timeStr.split(':');
            if (parts.length !== 2) {
                showError('Введите время в формате ММ:СС (например, 45:00 или 77:05)');
                timeInput.focus();
                return;
            }

            const mins = parseInt(parts[0], 10);
            const secs = parseInt(parts[1], 10);

            if (isNaN(mins) || isNaN(secs) || mins < 0 || secs < 0 || secs >= 60) {
                showError('Некорректное время. Минуты и секунды должны быть числами, секунды < 60.');
                timeInput.focus();
                return;
            }

            const totalSeconds = mins * 60 + secs;
            const half = totalSeconds > 45 * 60 ? 2 : 1;

            if (sendCommand('set_custom_time', { time: totalSeconds, half })) {
                showSuccess(`Время установлено: ${timeStr}`);
                timeInput.value = '';
            }
        }

        function toggleHalf(half) {
            if (sendCommand('toggle_half', { half })) {
                currentHalf = half;
            }
        }

        // === Обновление UI ===
        function updateUI(newState) {
            if (!newState) {
                showError('Получено пустое состояние');
                return;
            }
            
            state = newState;
            currentHalf = newState.currentHalf;

            // Обновляем счёт и таймер
            document.getElementById('team1Score').textContent = newState.team1Score || 0;
            document.getElementById('team2Score').textContent = newState.team2Score || 0;
            updateTimer(newState.time || 0);
            
            // Обновляем элементы управления
            const btn1 = document.getElementById('startHalf1');
            const btn2 = document.getElementById('startHalf2');
            const halfIndicator = document.getElementById('halfIndicator');
            const autoStopCb = document.getElementById('autoStop');
            const muteBtn = document.getElementById('muteBtn');

            if (autoStopCb) autoStopCb.checked = newState.autoStop;
            if (muteBtn) muteBtn.textContent = newState.isMuted ? 'Unmute' : 'Mute';
            
            // Обновляем индикатор тайма
            const halfText = currentHalf + (newState.timerRunning ? ' тайм (активен)' : ' тайм');
            if (halfIndicator) halfIndicator.textContent = halfText;

            // Обновляем кнопки
            if (btn1) {
                btn1.textContent = (currentHalf === 1 && newState.timerRunning) ? 'Пауза 1 тайм' : 'Старт 1 тайм';
                btn1.setAttribute('aria-label', btn1.textContent);
            }
            
            if (btn2) {
                btn2.textContent = (currentHalf === 2 && newState.timerRunning) ? 'Пауза 2 тайм' : 'Старт 2 тайм';
                btn2.setAttribute('aria-label', btn2.textContent);
            }

            // Обновляем фон
            if (newState.background?.image) {
                setupBackground(newState.background);
            }
            
            // Обновляем настройки шрифтов
            if (newState.fontSettings) {
                const fs = newState.fontSettings;
                const scoreSizeEl = document.getElementById('scoreSize');
                const timerSizeEl = document.getElementById('timerSize');
                const scoreFontEl = document.getElementById('scoreFont');
                const timerFontEl = document.getElementById('timerFont');
                
                if (scoreSizeEl && fs.teamScore) scoreSizeEl.value = fs.teamScore.fontSize;
                if (timerSizeEl && fs.timer) timerSizeEl.value = fs.timer.fontSize;
                if (scoreFontEl && fs.teamScore?.fontFamily) scoreFontEl.value = fs.teamScore.fontFamily;
                if (timerFontEl && fs.timer?.fontFamily) timerFontEl.value = fs.timer.fontFamily;
            }
        }

        function updateTimer(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            const timerEl = document.getElementById('timerDisplay');
            if (timerEl) {
                timerEl.textContent = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
        }

        // === Управление фоном ===
        function setupBackground(bg) {
            const img = document.getElementById('backgroundImage');
            if (!img) return;
            
            img.src = bg.image;
            img.style.display = 'block';
            currentScale = bg.scale || 1.0;
            img.style.transform = `scale(${currentScale})`;
            updateBackgroundPosition(bg.position.x || 0, bg.position.y || 0);
            updateBackgroundFixedState(bg.fixed || false);
        }

        function updateBackgroundPosition(x, y) {
            const img = document.getElementById('backgroundImage');
            if (img) {
                img.style.left = x + 'px';
                img.style.top = y + 'px';
                img.style.position = 'absolute';
            }
        }

        function moveBackground(dx, dy) {
            const step = parseInt(document.getElementById('bgStep').value) || 10;
            const img = document.getElementById('backgroundImage');
            if (!img || img.style.display === 'none') return;

            let x = parseInt(img.style.left) || 0;
            let y = parseInt(img.style.top) || 0;

            x += dx * step;
            y += dy * step;

            img.style.left = x + 'px';
            img.style.top = y + 'px';
            sendCommand('update_background_position', { x, y });
        }

        function resetBackgroundPosition() {
            const img = document.getElementById('backgroundImage');
            if (!img) return;
            img.style.left = '0px';
            img.style.top = '0px';
            sendCommand('update_background_position', { x: 0, y: 0 });
        }

        function applyBackgroundPosition() {
            const x = parseInt(document.getElementById('bgX').value) || 0;
            const y = parseInt(document.getElementById('bgY').value) || 0;
            const img = document.getElementById('backgroundImage');
            if (!img || img.style.display === 'none') return;

            img.style.left = x + 'px';
            img.style.top = y + 'px';
            sendCommand('update_background_position', { x, y });
        }

        function updateBackgroundFixedState(fixed) {
            isBackgroundFixed = fixed;
            const img = document.getElementById('backgroundImage');
            const btn = document.getElementById('fixBackgroundBtn');
            
            if (img && btn) {
                if (fixed) {
                    img.classList.add('fixed');
                    btn.textContent = 'Разблокировать фон';
                } else {
                    img.classList.remove('fixed');
                    btn.textContent = 'Зафиксировать фон';
                }
            }
        }

        function toggleBackgroundFixed() {
            sendCommand('toggle_background_fixed');
        }

        function scaleBackground(factor) {
            const img = document.getElementById('backgroundImage');
            if (img && img.style.display !== 'none') {
                currentScale *= factor;
                currentScale = Math.max(0.1, Math.min(5.0, currentScale)); // Ограничиваем масштаб
                img.style.transform = `scale(${currentScale})`;
                sendCommand('update_background_size', { scale: currentScale });
            }
        }

        // === Управление шрифтами ===
        function updateFontSize(element, inputId) {
            const sizeEl = document.getElementById(inputId);
            if (!sizeEl) return;
            
            const size = parseFloat(sizeEl.value);
            if (isNaN(size) || size <= 0) {
                showError('Некорректный размер шрифта');
                return;
            }
            
            if (sendCommand('update_font_size', { element, size })) {
                showSuccess(`Размер шрифта обновлён: ${size}em`);
            }
        }

        function updateFontFamily(element, selectId) {
            const selectEl = document.getElementById(selectId);
            if (!selectEl) return;
            
            const fontFamily = selectEl.value;
            if (!fontFamily) {
                showError('Выберите шрифт');
                return;
            }
            
            if (sendCommand('update_font_family', { element, fontFamily })) {
                showSuccess(`Шрифт обновлён: ${fontFamily}`);
            }
        }

        function updateFontSelects(fonts) {
            ['scoreFont', 'timerFont'].forEach(id => {
                const select = document.getElementById(id);
                if (!select) return;
                
                const currentValue = select.value;
                select.innerHTML = '<option value="">Выберите шрифт</option>';
                
                fonts.forEach(font => {
                    const opt = document.createElement('option');
                    opt.value = font.fontFamily;
                    opt.textContent = font.fontFamily;
                    select.appendChild(opt);
                });
                
                // Восстанавливаем выбранное значение
                if (currentValue && fonts.find(f => f.fontFamily === currentValue)) {
                    select.value = currentValue;
                }
            });

            // Устанавливаем текущие значения из состояния
            if (state.fontSettings) {
                const scoreFontEl = document.getElementById('scoreFont');
                const timerFontEl = document.getElementById('timerFont');
                
                if (scoreFontEl && state.fontSettings.teamScore?.fontFamily) {
                    scoreFontEl.value = state.fontSettings.teamScore.fontFamily;
                }
                if (timerFontEl && state.fontSettings.timer?.fontFamily) {
                    timerFontEl.value = state.fontSettings.timer.fontFamily;
                }
            }
        }

        // === Перетаскивание фона ===
        let isDragging = false;
        let dragStartX, dragStartY;
        let startLeft, startTop;
        let bgImage;
        let hitLayer;
        
        function initDrag() {
            bgImage = document.getElementById('backgroundImage');
            hitLayer = document.getElementById('backgroundHitLayer'); // ← Новый слой
            if (!bgImage || !hitLayer) return;
            
            // Слушаем mousedown на документе
            document.addEventListener('mousedown', handleMouseDown);
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            
            document.addEventListener('mousemove', throttledDrag);
            document.addEventListener('touchmove', throttledDrag, { passive: false });
            
            document.addEventListener('mouseup', stopDrag);
            document.addEventListener('touchend', stopDrag);
        }

        function handleMouseDown(e) {
            if (isBackgroundFixed) return; // ← Только фиксация
            // Проверка e.target УДАЛЕНА — клик в любом месте экрана начнёт drag!
            // ❌ Игнорируем клики на интерактивных элементах
            const interactiveElements = [
                'BUTTON', 'INPUT', 'TEXTAREA', 'SELECT', 'LABEL',
                'A', 'VIDEO', 'AUDIO', 'CANVAS', 'IFRAME'
            ];

            // ❌ Игнорируем элементы с определёнными классами (если нужно)
            const interactiveClasses = [
                '.font-controls', '.background-controls', '.controls',
                '.score-display', '.connection-indicator', '.error-message',
                '.success-message', '.timer', '.team'
            ];

            let target = e.target;

            // Проверяем тег
            if (interactiveElements.includes(target.tagName)) {
                return;
            }

            // Проверяем классы
            for (let cls of interactiveClasses) {
                if (target.closest(cls)) {
                    return;
                }
            }
        //Если дошли сюда — начинаем drag
            startDrag(e);
        }

        function handleTouchStart(e) {
            if (!e.touches?.[0] || isBackgroundFixed) return;

            const target = e.touches[0].target;

            const interactiveElements = [
                'BUTTON', 'INPUT', 'TEXTAREA', 'SELECT', 'LABEL',
                'A', 'VIDEO', 'AUDIO', 'CANVAS', 'IFRAME'
            ];

            const interactiveClasses = [
                '.font-controls', '.background-controls', '.controls',
                '.score-display', '.connection-indicator', '.error-message',
                '.success-message', '.timer', '.team'
            ];

            if (interactiveElements.includes(target.tagName)) {
                return;
            }

            for (let cls of interactiveClasses) {
                if (target.closest(cls)) {
                    return;
                }
            }
        //Если дошли сюда — начинаем drag xD x2 Javohir?
            startDrag(e);
        }

        function startDrag(e) {
            e.preventDefault();
            isDragging = true;
            
            const clientX = e.clientX || e.touches?.[0]?.clientX;
            const clientY = e.clientY || e.touches?.[0]?.clientY;
            if (!clientX || !clientY) return;
            
            dragStartX = clientX;
            dragStartY = clientY;
            startLeft = parseInt(bgImage.style.left) || 0;
            startTop = parseInt(bgImage.style.top) || 0;
            
            bgImage.style.cursor = 'grabbing';
            bgImage.style.pointerEvents = 'none';
            
            // 👇 Активируем хит-слой
            if (hitLayer) {
                hitLayer.style.display = 'block';
                hitLayer.classList.add('dragging');
            }
        }

        function stopDrag() {
            if (isDragging) {
                isDragging = false;
                
                if (bgImage) {
                    bgImage.style.cursor = 'grab';
                    bgImage.style.pointerEvents = 'auto';
                    
                    const x = parseInt(bgImage.style.left) || 0;
                    const y = parseInt(bgImage.style.top) || 0;
                    sendCommand('update_background_position', { x, y });
                }
                
                // 👇 Деактивируем хит-слой
                if (hitLayer) {
                    hitLayer.classList.remove('dragging');
                    hitLayer.style.display = 'none';
                }
            }
        }

        const throttledDrag = throttle((e) => {
            if (!isDragging || isBackgroundFixed) return; // 👈 Главный флаг!
            
            e.preventDefault();
            
            const clientX = e.clientX || e.touches?.[0]?.clientX;
            const clientY = e.clientY || e.touches?.[0]?.clientY;
            if (!clientX || !clientY) return;
            
            const dx = clientX - dragStartX;
            const dy = clientY - dragStartY;
            
            let x = startLeft + dx;
            let y = startTop + dy;
            
            // Ограничиваем, чтобы не улетало слишком далеко
            x = Math.max(-window.innerWidth * 2, Math.min(window.innerWidth * 3, x));
            y = Math.max(-window.innerHeight * 2, Math.min(window.innerHeight * 3, y));
            
            bgImage.style.left = x + 'px';
            bgImage.style.top = y + 'px';
        }, 16);

        // === Обработка файлов ===
        function initFileUpload() {
            const uploadEl = document.getElementById('backgroundUpload');
            if (!uploadEl) return;
            
            uploadEl.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                // Проверка типа файла
                if (!file.type.startsWith('image/')) {
                    showError('Выберите файл изображения');
                    return;
                }
                
                // Проверка размера файла (макс 10MB)
                if (file.size > 10 * 1024 * 1024) {
                    showError('Файл слишком большой (максимум 10MB)');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = e => {
                    if (sendCommand('set_background', {
                        image: e.target.result,
                        position: { x: 0, y: 0 },
                        scale: 1.0,
                        fixed: false
                    })) {
                        showSuccess('Фон загружен');
                    }
                };
                reader.onerror = () => showError('Ошибка чтения файла');
                reader.readAsDataURL(file);
            });
        }

        // === Инициализация ===
        window.addEventListener('load', () => {
            connect();
            initDrag();
            initFileUpload();
            
            // Обработчик для Enter в поле времени
            const timeInput = document.getElementById('timeInput');
            if (timeInput) {
                timeInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        setCustomTime();
                    }
                });
            }
            
            // Предотвращение случайного закрытия страницы
            window.addEventListener('beforeunload', (e) => {
                if (isConnected) {
                    e.preventDefault();
                    e.returnValue = 'Вы уверены, что хотите покинуть панель управления?';
                }
            });
        });

        // === Обработка ошибок ===
        window.addEventListener('error', (e) => {
            console.error('JavaScript error:', e.error);
            showError(`Ошибка приложения: ${e.message}`);
        });

        // === Клавиатурные shortcuts ===
        document.addEventListener('keydown', (e) => {
            if (!isConnected) return;
            
            // Только если не в поле ввода
            if (e.target.tagName === 'INPUT') return;
            
            switch (e.key) {
                case '1':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        sendCommand('add_goal', {team: 1});
                    }
                    break;
                case '2':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        sendCommand('add_goal', {team: 2});
                    }
                    break;
                case ' ':
                    e.preventDefault();
                    toggleHalf(currentHalf);
                    break;
                case 'r':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        sendCommand('reset', {half: currentHalf});
                    }
                    break;
            }
        });
    </script>
</body>
</html>